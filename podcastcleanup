#!/usr/bin/python3

import multiprocessing
import os
import re
import subprocess
import util

HOME = os.path.expanduser("~")
PODCASTS_DIR = os.path.join(HOME, "Dropbox", "mini", "podcasts")
FOLDERS = sorted(
    [d for d in os.listdir(".") if os.path.isdir(d) and not d.startswith(".")]
)
DATE_PATTERN = r"^\d\d\d\d\-\d\d\-\d\d"

TAGS_DB = {}
SEEN_DURATIONS = []
SEEN_FP = []


def hash(the_file):
    return subprocess.check_output(["md5sum", the_file]).decode().split(" ")[0]

def process_id3v2_tags(fp, data):
    tags = {}
    for l in data.split("\n"):
        if ":" not in l:
            continue
        (tag, value) = l.split(":", 1)
        tag = tag[:4]
        tags[tag] = value
    TAGS_DB[fp] = tags

def get_tag_from_cache(fp, tag):
    if fp in TAGS_DB:
        if tag in TAGS_DB[fp]:
            return TAGS_DB[fp][tag]
    return None

def get_tag(e, tag):
    fp = hash(e)
    cached = get_tag_from_cache(fp, tag)
    if cached:
        return cached
    data = subprocess.check_output(["id3v2", "-l", e]).decode().strip()
    if "no id3v2 tags" not in data.lower() and data != "":
        process_id3v2_tags(fp, data)
    return get_tag_from_cache(fp, tag)
    #except UnicodeDecodeError:
    # ids = subprocess.check_output(shlex.split("eyeD3 " + e)).decode()
    # if ids:
        # for l in ids.split("\n"):
            # if "title" in l:
                # return l.split(":", 1)[1].strip()

def get_episode_number(e):
    for t in ["TRCK"]:
        candidate = get_tag(e, t)
        if candidate and int(candidate) > 1:
            return str(int(candidate)).zfill(4)
    return None

def get_title(e):
    for t in ["TIT2"]:
        candidate = get_tag(e, t)
        if candidate:
            return candidate
    # print(TAGS_DB[hash(e)])
    return "unknown"

def get_date(e):
    for t in ["TDAT"]:
        candidate = get_tag(e, t)
        if candidate:
            dateparts = candidate.split("-")
            if len(dateparts) != 3:
                return None
            # Reverse the date format.
            date = "-".join([dateparts[2], dateparts[1], dateparts[0]])
            if re.match(DATE_PATTERN, date) is not None:
                return date
    # except UnicodeDecodeError:
        # noop = "hop"
    return None

def get_duration(e):
    duration = "unknown"
    try:
        duration = subprocess.check_output(["mp3info", "-p", "'%m:%s\n'", e]).decode()
        duration = duration.replace("'", "").replace(":", "m").strip()
        duration = [d.zfill(2) for d in duration.split("m")]
    except subprocess.CalledProcessError:
        print("Couldn't get duration for " + e)
    return "m".join(duration)

def process_one_episode(e):
    date_prefix = util.get_date_prefix()
    # If the file already has a date prefix, preserve it
    if re.match(DATE_PATTERN, e) is not None:
        date_prefix = e[:10]
    title = get_title(e)
    date = get_date(e)
    duration = get_duration(e)
    episode_number = get_episode_number(e)
    if date:
        date_prefix = date
    title = util.sanitize_for_filename(title)
    if title.startswith("."):
        title = title[1:]
    fp = hash(e)
    if duration not in SEEN_DURATIONS:
        SEEN_DURATIONS.append(duration)
    if fp in SEEN_FP:
        cmd = "rm " + e
        #print(cmd)
        #os.system(cmd)
    else:
        SEEN_FP.append(fp)
    parts = [date_prefix]
    if episode_number:
        parts.append(episode_number)
    parts.append(title)
    parts.append(duration)
    final_name = "_".join(parts) + ".mp3"
    if e != final_name:
        cmd = "mv '" + e + "' '" + final_name + "'"
        print(cmd)
        os.system(cmd)
    return "unused_result"

def keep_only_latest_episode_in_folder_matching_name(name):
    for f in FOLDERS:
        if name in f.lower():
            os.chdir(f)
            episodes = sorted([f for f in os.listdir() if f.endswith(".mp3")])
            if len(episodes) > 1:
                cmd = "rm " + " ".join(["'" + e + "'" for e in episodes[:-1]])
                print(cmd)
                os.system(cmd)
            os.chdir("..")

os.chdir(PODCASTS_DIR)
util.run_bin_cmd("sanitizefilenamesrecursively")
os.system("find . -name '*conflicted*' -delete")
os.system("rm -rf *Conflict*")
os.system("rm -f .LOG/errors")

for f in FOLDERS:
    if not os.path.exists(f):
        continue
    os.chdir(f)
    episodes = sorted([f for f in os.listdir() if f.endswith(".mp3")])
    n_threads = multiprocessing.cpu_count() - 1
    pool = multiprocessing.Pool(n_threads)
    results = pool.map(process_one_episode, episodes)
    pool.close()
    pool.join()
    os.chdir("..")

keep_only_latest_episode_in_folder_matching_name("matins_de_france_culture")
keep_only_latest_episode_in_folder_matching_name("journal_de_7h30")

for f in FOLDERS:
    if not os.path.exists(f):
        continue
    os.chdir(f)
    episodes = sorted([f for f in os.listdir() if f.endswith(".mp3")])
    os.chdir("..")
    if len(episodes) == 0:
        os.system("rmdir '" + f + "'")


os.chdir(".LOG")
log_files = os.listdir(".")
for l in log_files:
    if "conflict" in l:
        os.system('rm "' + l + '"')
os.chdir("..")

print("Removing backups...")
os.system("find -name '*.bup' -delete")
print("Down-sampling...")
os.system("downsampleallmp3srecursively 64")
print("Removing backups again...")
os.system("find -name '*.bup' -delete")
print("All done.")
